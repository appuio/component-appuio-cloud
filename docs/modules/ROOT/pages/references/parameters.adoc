= Parameters

The parent key for all of the following parameters is `appuio_cloud`.

== `namespace`

[horizontal]
type:: string
default:: `syn-appuio-cloud`

The namespace in which to deploy this component.

== `reservedNamespaces`

[horizontal]
type:: dict
example::
+
[source,yaml]
----
reservedNamespaces:
  monitoring: ['monitoring-*', 'test-monitoring-*']
  logging: logging
----

Creating and editing namespaces matching any of the entries is disallowed.
The list must consist of entries like `custom: ['custom-*', 'test-custom-*']` or `custom: 'custom-*'`.

== `bypassNamespaceRestrictions.roles`

[horizontal]
type:: dict
example::
+
[source,yaml]
----
roles:
  my-admin: ['my-admin', 'test-admin']
  special-role: special-role
----

`Roles` in the same namespace excluded from all namespace policies.
Must consist of entries like `my-admin: ['my-admin', 'test-admin']` or `my-admin: 'my-admin'`.

== `bypassNamespaceRestrictions.clusterRoles`

[horizontal]
type:: dict
example::
+
[source,yaml]
----
clusterRoles:
  my-admin: ['my-admin', 'test-admin']
  special-role: special-role
----

`ClusterRoles` excluded from all namespace policies.
Must consist of entries like `my-admin: ['my-admin', 'test-admin']` or `my-admin: 'my-admin'`.

== `bypassNamespaceRestrictions.subjects`

[horizontal]
type:: dict
example::
+
[source,yaml]
----
subjects:
  argocd:
    kind: ServiceAccount
    name: argocd-application-controller
    namespace: syn-argocd
----

`ServiceAccount`, `User` or `Group` (chosen by `kind:`) excluded from all namespace policies.

== `generatedDefaultRoleBindingInNewNamespaces.clusterRoleName`

[horizontal]
type:: string
default:: `admin`

The `ClusterRole` name to which the requesting user account gets a new `RoleBinding` to.

== `generatedDefaultRoleBindingInNewNamespaces.bindingName`

[horizontal]
type:: string
default:: `admin`

The `metadata.name` of the `RoleBinding` that gets generated in the new `Namespace` created by the user.
The role binding is only created upon Namespace creation, it doesn't get synchronized.

== `generatedResourceQuota`

[horizontal]
type:: dict

A key-value map defining multiple `ResourceQuota`.
Each entry will generate a `ResourceQuota` with the key as its name.

=== `generatedResourceQuota[name].synchronize`

[horizontal]
type:: bool
default:: `true`

Whether the created `ResourceQuota` is kept in sync.
If set to `false` the created `ResourceQuota` can be modified.

[WARNING]
====
There is a bug in `kyverno` up until `v1.4.2`.
The bug has been fixed, but as of writing this the fix hasn't been released.
The bug will cause the `ResourceQuota` to be updated if the `Namespace` or `ClusterPolicy` changes, even if `synchronize` has been disabled.
====

=== `generatedResourceQuota[name].hard`

[horizontal]
type:: dict

The desired hard limits for each named resource.
Consult https://kubernetes.io/docs/concepts/policy/resource-quotas/[the official Kubernetes documentation] on how to configure these limits.


=== `generatedResourceQuota[name].scopes`

[horizontal]
type:: list
default:: []
example::
+
[source,yaml]
----
scopes:
  - Terminating
  - BestEffort
----

Each quota can have an associated set of scopes.
A quota will only measure usage for a resource if it matches the intersection of enumerated scopes.
Consult https://kubernetes.io/docs/concepts/policy/resource-quotas/#quota-scopes[the official Kubernetes documentation] on how to configure these scopes.

=== `generatedResourceQuota[name].scopeSelector`

ScopeSelector is also a collection of filters like Scopes that must match each object tracked by a quota.
Consult https://kubernetes.io/docs/concepts/policy/resource-quotas/#quota-scopes[the official Kubernetes documentation] on how to configure this `scopeSelector`.

[horizontal]
type:: dict
default:: null
example::
+
[source,yaml]
----
scopeSelector:
  matchExpressions:
    - scopeName: PriorityClass
      operator: In
      values:
        - middle
----

== `generatedLimitRange.name`

[horizontal]
type:: string
default:: `organization`

The `metadata.name` of the `LimitRange` that gets generated in the new `Namespace` created by the user.

== `generatedResourceQuota.synchronize`

[horizontal]
type:: bool
default:: `true`

Whether the created `LimitRange` is kept in sync.
If set to `false` the created `LimitRange` can be modified.

[WARNING]
====
There is a bug in `kyverno` up until `v1.4.2`.
The bug has been fixed, but as of writing this the fix hasn't been released.
The bug will cause the `LimitRange` to be updated if the `Namespace` or `ClusterPolicy` changes, even if `synchronize` has been disabled.
====

== `generatedLimitRange.limits`

[horizontal]
type:: dict
example::
+
[source,yaml]
----
limits:
  "Container":
    max:
      memory: "4G"
    min:
      memory: "4Mi"
  "PersistentVolumeClaim":
    max:
      storage: 2Gi
    min:
      storage: 1Gi
----

A key-value map defining limits for different `Types`.


The example above will reject any PVC smaller than `1Gi` or larger than `2Gi`.
It will also reject any container requesting more than `4G` of memory or less than `4Mi`.


Consult https://kubernetes.io/docs/concepts/policy/limit-range/[the official Kubernetes documentation] on how to configure these `limits`.

